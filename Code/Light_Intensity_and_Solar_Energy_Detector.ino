         /////////////////////////////////////////////  
        //    Light Intensity and Solar Energy     //
       //        Detector with Tilt Sensor        //
      //             ---------------             //
     //             (Arduino Nano)              //           
    //             by Kutluhan Aktar           // 
   //                                         //
  /////////////////////////////////////////////

// Evaluate the possible magnitude of solar energy by the light intensity in a given direction to charge batteries efficiently.
//
// The amount of energy generated by a solar panel is related to the amount of solar radiation. Which is why, I used light intensity values as a substitute to calculate it approximately.
//
// Threshold indicators for each direction:
//
// Red - Low
// Yellow - Moderate
// Green - High 
//
// I determine the thresholds for each level by conducting tests with my solar panel: I observed time passed in a given light intensity value to full-charge a 3.7V Li-Po battery.
//
// So, do not forget to change the thresholds according to your experiments with your battery and solar panel.
//
// Connections
// Arduino Nano :           
//                                direction_1_LOW
// D4  ---------------------------
//                                direction_1_MODERATE
// D3  ---------------------------
//                                direction_1_HIGH
// D2  ---------------------------
//                                direction_2_LOW
// D7  ---------------------------
//                                direction_2_MODERATE
// D6  ---------------------------
//                                direction_2_HIGH
// D5  ---------------------------
//                                direction_3_LOW
// D8  ---------------------------
//                                direction_3_MODERATE
// D9  ---------------------------
//                                direction_3_HIGH
// D10 ---------------------------
//                                direction_4_LOW
// D13 ---------------------------
//                                direction_4_MODERATE
// A4  ---------------------------
//                                direction_4_HIGH
// A5  ---------------------------
//                                Buzzer
// D11 ---------------------------
//                                Tilt Sensor
// D12 ---------------------------
//                                direction_1_LDR
// A0  ---------------------------
//                                direction_2_LDR
// A1  ---------------------------
//                                direction_3_LDR
// A2  ---------------------------
//                                direction_4_LDR
// A3  ---------------------------


// Define indicators (red, yellow, green) for each direction.
#define direction_1_LOW 4
#define direction_1_MODERATE 3
#define direction_1_HIGH 2
#define direction_2_LOW 7
#define direction_2_MODERATE 6
#define direction_2_HIGH 5
#define direction_3_LOW 8
#define direction_3_MODERATE 9
#define direction_3_HIGH 10
#define direction_4_LOW 13
#define direction_4_MODERATE 18
#define direction_4_HIGH 19

// Define LDR pins for each direction to gather light intensity values.
#define direction_1_LDR A0
#define direction_2_LDR A1
#define direction_3_LDR A2
#define direction_4_LDR A3

// Define the buzzer pin and the tilt sensor pin.
#define buzzerPin 11 
#define tiltPin 12

// Define the solar panel (SP) specifications which differ amid different brands. So, change these variables with that of your solar panel.
#define SP_area 0.0088
#define SP_efficiency 6.2
#define SP_coefficient 0.75

// Define thresholds by experimenting.
#define low 9.15
#define moderate 19.48 
  
// Define data holders:
int LDR_1, LDR_2, LDR_3, LDR_4;


void setup() {
  Serial.begin(9600);
  Serial.print("\nDevice Activated:\n");
  Serial.print("Do not forget to change solar panel specifications and thresholds!\n");
  
  pinMode(direction_1_LOW, OUTPUT);
  pinMode(direction_1_MODERATE, OUTPUT);
  pinMode(direction_1_HIGH, OUTPUT);
  pinMode(direction_2_LOW, OUTPUT);
  pinMode(direction_2_MODERATE, OUTPUT);
  pinMode(direction_2_HIGH, OUTPUT);
  pinMode(direction_3_LOW, OUTPUT);
  pinMode(direction_3_MODERATE, OUTPUT);
  pinMode(direction_3_HIGH, OUTPUT);
  pinMode(direction_4_LOW, OUTPUT);
  pinMode(direction_4_MODERATE, OUTPUT);
  pinMode(direction_4_HIGH, OUTPUT);
  
  pinMode(tiltPin, INPUT);

}

void loop() {
  // Gather light intensity data from photoresistors.
  get_Light_Intensity();

  // Activate the tilt sensor to get accurate results with photoresistors.
  Tilt(digitalRead(tiltPin));

  // Initiate threshold detection for each direction:

  // Direction (1):
  Indicate_Thresholds(Solar_Panel_Energy(SP_area, SP_efficiency, LDR_1, SP_coefficient), direction_1_LOW, direction_1_MODERATE, direction_1_HIGH, 1);
  
  // Direction (2):
  Indicate_Thresholds(Solar_Panel_Energy(SP_area, SP_efficiency, LDR_2, SP_coefficient), direction_2_LOW, direction_2_MODERATE, direction_2_HIGH, 2);
  
  // Direction (3):
  Indicate_Thresholds(Solar_Panel_Energy(SP_area, SP_efficiency, LDR_3, SP_coefficient), direction_3_LOW, direction_3_MODERATE, direction_3_HIGH, 3);
  
  // Direction (4):
  Indicate_Thresholds(Solar_Panel_Energy(SP_area, SP_efficiency, LDR_4, SP_coefficient), direction_4_LOW, direction_4_MODERATE, direction_4_HIGH, 4);
 
}

void get_Light_Intensity(){
  LDR_1 = analogRead(direction_1_LDR);
  LDR_2 = analogRead(direction_2_LDR);
  LDR_3 = analogRead(direction_3_LDR);
  LDR_4 = analogRead(direction_4_LDR);

}

void Tilt(int tilt){
  // Get notified if the device moves into a sloping position.
  if(tilt == HIGH){
    tone(buzzerPin, 350);
  }else if(tilt == LOW){
    noTone(buzzerPin);
  }
}
  
float Solar_Panel_Energy(float Area, float Efficiency, int Radiation, float Coefficient){
  // Calculate the possible magnitude of solar energy by using the light intensity values as a substitute for radiation. 
  float Energy = Area * Efficiency * Radiation * Coefficient;
  return Energy;
}

void Indicate_Thresholds(float predictedEnergy, int red, int yellow, int green, int direction){
  // Print the selected direction.
  Serial.print("Direction ("); 
  Serial.print(direction); 
  Serial.print(") = \t");
  Serial.print(predictedEnergy);
  Serial.print("\n");
  // THRESHOLDS:       
  if(predictedEnergy < low){
    digitalWrite(red, HIGH);
    digitalWrite(yellow, LOW);
    digitalWrite(green, LOW);
  }else if(low <= predictedEnergy && predictedEnergy < moderate){
    digitalWrite(red, HIGH);
    digitalWrite(yellow,HIGH);
    digitalWrite(green, LOW);
  }else if(predictedEnergy >= moderate){
    digitalWrite(red, HIGH);
    digitalWrite(yellow, HIGH);
    digitalWrite(green, HIGH);
  }
          
}
     
